Index: app/src/main/java/com/example/radiocoveragetesting/testingActivity.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.radiocoveragetesting;\r\n\r\nimport android.content.Context;\r\nimport android.content.Intent;\r\nimport android.graphics.Color;\r\nimport android.os.Bundle;\r\nimport android.os.Handler;\r\nimport android.os.HandlerThread;\r\nimport android.os.Looper;\r\nimport android.util.Log;\r\nimport android.view.View;\r\nimport android.view.View;\r\nimport android.widget.AdapterView;\r\nimport android.widget.ArrayAdapter;\r\nimport android.widget.Button;\r\nimport android.widget.Spinner;\r\nimport android.widget.TextView;\r\n\r\nimport androidx.appcompat.app.AppCompatActivity;\r\n\r\nimport org.apache.sshd.client.SshClient;\r\nimport org.apache.sshd.client.channel.ClientChannel;\r\nimport org.apache.sshd.client.session.ClientSession;\r\nimport org.apache.sshd.common.SshException;\r\nimport org.apache.sshd.common.channel.Channel;\r\nimport org.apache.sshd.common.channel.exception.SshChannelOpenException;\r\nimport org.apache.sshd.server.forward.AcceptAllForwardingFilter;\r\nimport java.io.ByteArrayOutputStream;\r\nimport java.io.IOException;\r\nimport java.io.OutputStream;\r\nimport java.util.ArrayList;\r\nimport java.util.Objects;\r\nimport java.util.concurrent.TimeUnit;\r\n\r\npublic class testingActivity extends AppCompatActivity implements AdapterView.OnItemSelectedListener {\r\n\r\n    TextView snrUp;\r\n    TextView snrDown;\r\n    TextView peakSnrUp;\r\n    TextView peakSnrDown;\r\n    TextView avgPwrUp;\r\n    TextView avgPwrDown;\r\n    TextView peakPwrUp;\r\n    TextView peakPwrDown;\r\n    Button startStop;\r\n    Button export;\r\n    String host, username, password;\r\n    Integer port;\r\n    Handler sshHandler;\r\n    ClientSession sshSession;\r\n    ClientChannel sshChannel;\r\n    ByteArrayOutputStream responseStream;\r\n    Runnable updater, establishSsh;\r\n    SshClient client;\r\n    Handler mainHandler;\r\n    HandlerThread thread;\r\n    ByteArrayOutputStream errStream;\r\n    Spinner spinnerBaseStation, spinnerSector;\r\n    Boolean retryFetchStat;\r\n    Boolean updateEnabled;\r\n    private boolean justStarted;\r\n\r\n\r\n\r\n    protected void onCreate(Bundle savedInstanceState) {\r\n        Log.d(\"test\", \"the testingActivity works\");\r\n        super.onCreate(savedInstanceState);\r\n        setContentView(R.layout.activity_testing);\r\n        retryFetchStat = true;\r\n\r\n        spinnerBaseStation = findViewById(R.id.select_sector);\r\n        ArrayAdapter<CharSequence>adapter1 = ArrayAdapter.createFromResource(this, R.array.Base_station_list, android.R.layout.simple_spinner_item);\r\n        adapter1.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);\r\n        spinnerBaseStation.setAdapter(adapter1);\r\n        spinnerBaseStation.setOnItemSelectedListener(this);\r\n\r\n        spinnerSector = findViewById(R.id.select_tower);\r\n\r\n\r\n\r\n        Intent intent = getIntent();\r\n\r\n        snrUp = findViewById(R.id.SNR_Up);\r\n        snrDown = findViewById(R.id.SNR_Down);\r\n        peakSnrUp = findViewById(R.id.peak_SNR_up);\r\n        peakSnrDown = findViewById(R.id.peak_SNR_down);\r\n        avgPwrUp = findViewById(R.id.avg_PWR_up);\r\n        avgPwrDown = findViewById(R.id.avg_PWR_down);\r\n        peakPwrUp = findViewById(R.id.peak_PWR_up);\r\n        peakPwrDown = findViewById(R.id.peak_PWR_down);\r\n        startStop = findViewById(R.id.start_stop);\r\n        export = findViewById(R.id.export);\r\n\r\n        //get login cred from intent\r\n        host = intent.getStringExtra(\"host\");\r\n        port = Integer.parseInt(intent.getStringExtra(\"port\"));\r\n        username = intent.getStringExtra(\"username\");\r\n        password = intent.getStringExtra(\"password\");\r\n\r\n        //I don't get what this does, but the code breaks without it\r\n        // Setting user.com property manually\r\n        // since isn't set by default in android\r\n        String key = \"user.home\";\r\n        Context sysContext;\r\n        sysContext = getApplicationContext();\r\n        String val = sysContext.getApplicationInfo().dataDir;\r\n        System.setProperty(key, val);\r\n\r\n        // Creating a client instance\r\n        client = SshClient.setUpDefaultClient();\r\n        client.setForwardingFilter(AcceptAllForwardingFilter.INSTANCE);\r\n        client.start();\r\n\r\n        //mainHandler allows a background thread to access main thread and update ui\r\n        //mainHandler = new Handler();\r\n\r\n        thread = new HandlerThread(\"MyHandlerThread\");\r\n        thread.start();\r\n        //sshHandler allows main thread to post runnable to background thread\r\n        sshHandler = new Handler(thread.getLooper());\r\n\r\n        //make a runnable to establish ssh session in background\r\n        establishSsh = new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                try {\r\n                    establishSshSession();\r\n                }\r\n                catch (Exception e) {\r\n                    System.out.println(\"issue 1\");\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        };\r\n        mainHandler = new Handler(Looper.getMainLooper());\r\n\r\n\r\n        //activate the said runnable in background\r\n        sshHandler.post(establishSsh);\r\n\r\n        //Setting onClick Listener for Start/Stop Button\r\n        startStop.setOnClickListener(new View.OnClickListener() {\r\n            @Override\r\n            public void onClick(View v) {\r\n                //Checks if button should start/stop ssh session\r\n                if(startStop.getText().equals(\"Start\")) {\r\n                    // Changes State of Button\r\n                    startStop.setText(\"Stop\");\r\n                    startStop.setBackgroundColor(Color.RED);\r\n\r\n                    updateEnabled = true;\r\n\r\n\r\n                    System.out.println(\"ssh established\");\r\n                    //create another runnable, for updates\r\n                    updater = new Runnable() {\r\n                        @Override\r\n                        public void run() {\r\n                            ArrayList<String> stat = fetchStats();\r\n\r\n                            Runnable myRunnable = new Runnable() {\r\n                                @Override\r\n                                public void run() {\r\n                                    updateStat(stat);\r\n                                    System.out.println(\"myRunnable running\");\r\n                                }\r\n                            };\r\n\r\n                            mainHandler.post(myRunnable);\r\n                            //sshHandler.postDelayed(updater,1000); //updateStat() does this now\r\n                        }\r\n                    };\r\n                    System.out.println(\"start update\");\r\n                    sshHandler.post(updater);\r\n                }\r\n                else {\r\n                    // Changes State of Button\r\n                    startStop.setText(\"Start\");\r\n                    startStop.setBackgroundColor(Color.GREEN);\r\n                    updateEnabled = false;\r\n                    /*\r\n                    try {\r\n                        sshHandler.removeCallbacks(updater);\r\n                        //sshHandler.removeCallbacks(establishSsh);\r\n                        //client.close();\r\n                        //thread.interrupt();\r\n                        System.out.println(\"Successfully Closed\");\r\n                    }\r\n\r\n\r\n                    catch(Exception e) {\r\n                        System.out.println(\"Either failed to close client or client did not exist\");\r\n                    }\r\n                    */\r\n\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Updates stat TextViews and also determines if update should continue\r\n     * Make sure to post it to mainHandler if using it in background\r\n     * @param stat ArrayList of stats\r\n     */\r\n    private void updateStat(ArrayList<String> stat) {\r\n\r\n        System.out.println(\"updateStat() running\");\r\n\r\n        if (stat.size() > 7) {\r\n\r\n            snrUp.setText(stat.get(0));\r\n            snrDown.setText(stat.get(1));\r\n            peakSnrUp.setText(stat.get(2));\r\n            peakSnrDown.setText(stat.get(3));\r\n            avgPwrUp.setText(stat.get(4));\r\n            avgPwrDown.setText(stat.get(5));\r\n            peakPwrUp.setText(stat.get(6));\r\n            peakPwrDown.setText(stat.get(7));\r\n        }\r\n\r\n        if (updateEnabled){\r\n            sshHandler.postDelayed(updater,1000);\r\n        }\r\n\r\n    }\r\n\r\n\r\n    /**\r\n     * Obtains the current stats and returns it\r\n     * currently uses the command \"go\"\r\n     * @return Array of list of strings that contain signal stat\r\n     */\r\n    private ArrayList<String> fetchStats() {\r\n        //change the command to new command that returns current stats later\r\n        String command = \"go\\n\";\r\n        System.out.println(\"fetchStats() running)\");\r\n        ArrayList<String> ans = new ArrayList<>();\r\n        try {\r\n\r\n            // Open channel\r\n            sshChannel.open().verify(5, TimeUnit.SECONDS);\r\n            sshSession.resetIdleTimeout();\r\n\r\n            try {\r\n                OutputStream pipedIn = sshChannel.getInvertedIn();\r\n                pipedIn.write(command.getBytes());\r\n                System.out.println(\"sending command\");\r\n                pipedIn.flush();\r\n                pipedIn.close();\r\n            }\r\n            catch (Exception e) {\r\n                e.printStackTrace();\r\n            }\r\n\r\n            //You gotta capture the string rather than\r\n            //scan it with scanner line-by-line because the stream constantly adds more\r\n            String responseString = new String(responseStream.toByteArray());\r\n            System.out.println(\"response string: \\n\" + responseString);\r\n            //break down the string into lines\r\n            String[] response = responseString.trim().split(\"\\n\");\r\n\r\n            //if this is first time the method is running since ssh connection\r\n            //was established, the output format will be wrong, so skip it once\r\n            if(!justStarted) {\r\n                //find the line containing the info we want\r\n                String answerLine = response[response.length - 2];\r\n                System.out.println(\"Testing line: \" + answerLine);//show it to log to manually check\r\n                //formatting the string\r\n                String[] answerArray = answerLine.split(\",\");\r\n\r\n                //I just did response 4-11 because I don't know the actual format of stats\r\n                ans.add(answerArray[4]);  //snrUp\r\n                ans.add(answerArray[5]);  //snrDown\r\n                ans.add(answerArray[6]);  //peakSnrUp\r\n                ans.add(answerArray[7]);  //peakSnrDown\r\n                ans.add(answerArray[8]);  //avgPwrUp\r\n                ans.add(answerArray[9]);  //avgPwrDown\r\n                ans.add(answerArray[10]); //peakPwrUp\r\n                ans.add(answerArray[11]); //peakPwrDown\r\n            }\r\n            justStarted = false;\r\n            retryFetchStat = true;\r\n        }\r\n        catch (Exception e) {\r\n            System.out.println(\"error in opening channel or getting response at fetchStat()\");\r\n            if((e instanceof SshChannelOpenException || e instanceof SshException) && (Objects.requireNonNull(e.getMessage()).trim().equals(\r\n                    \"open failed\") || Objects.requireNonNull(e.getMessage()).trim().equals(\r\n                    \"Session has been closed\"))) {\r\n                sshChannel.close(true);\r\n                sshSession.close(true);\r\n                try {\r\n                    responseStream.close();\r\n                }\r\n                catch (IOException e2) {\r\n                    e2.printStackTrace();\r\n                }\r\n                try {\r\n                    errStream.close();\r\n                }\r\n                catch (IOException e2) {\r\n                    e2.printStackTrace();\r\n                }\r\n                establishSshSession();\r\n                if (retryFetchStat) {\r\n                    retryFetchStat = false;\r\n                    fetchStats();\r\n                }\r\n\r\n            }\r\n            System.out.println(\"stacktrace for why first attempt failed\");\r\n            e.printStackTrace();\r\n        }\r\n        return ans;\r\n    }\r\n\r\n    /**\r\n     * Establishes sshSession\r\n     * Pretty sure that you need to call it in background thread.\r\n     * use sshHandler.post() to run it in background\r\n     * @return true if session is successfully established, else false\r\n     */\r\n    private boolean establishSshSession(){\r\n\r\n        try {\r\n            sshSession = client.connect(username, host, port).verify(10000).getSession();\r\n            sshSession.addPasswordIdentity(password);\r\n            sshSession.auth().verify(50000);\r\n            sshChannel = sshSession.createChannel(Channel.CHANNEL_SHELL);\r\n            responseStream = new ByteArrayOutputStream();\r\n            sshChannel.setOut(responseStream);\r\n            //set error stream\r\n            errStream = new ByteArrayOutputStream();\r\n            sshChannel.setErr(errStream);\r\n            justStarted = true;\r\n            return true;\r\n        }\r\n        catch (Exception e) {\r\n            System.out.println(\"failed to establish session\");\r\n            e.printStackTrace();\r\n            return false;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    protected void onDestroy() {\r\n        super.onDestroy();\r\n        sshHandler.removeCallbacksAndMessages(null);\r\n        sshHandler.getLooper().quit();\r\n    }\r\n\r\n    @Override\r\n    public void onItemSelected(AdapterView<?> adapterView, View view, int position, long l) {\r\n        Spinner spin = (Spinner) adapterView;\r\n        String[] baseStationList = getResources().getStringArray(R.array.Base_station_list);\r\n        int sectorListId;\r\n        if(spin.getId() == R.id.select_sector)\r\n        {\r\n            String selectedBaseStation = adapterView.getItemAtPosition(position).toString();\r\n            switch (selectedBaseStation) {\r\n                case \"DEA DO\":\r\n                    sectorListId = R.array.DEA_DO_sector_list;\r\n                    break;\r\n                case \"Edinberg\":\r\n                    sectorListId = R.array.Edinberg_sector_list;\r\n                    break;\r\n                case \"Mission\":\r\n                    sectorListId = R.array.Mission_sector_list;\r\n                    break;\r\n                case \"Wesclaco\":\r\n                    sectorListId = R.array.Weslaco_sector_list;\r\n                    break;\r\n                default:\r\n                    sectorListId = R.array.DEA_DO_sector_list; //merely a default. Should never happen\r\n                    System.out.println(\"problem processing base selection in onItemSelection()\");\r\n            }\r\n\r\n            ArrayAdapter<CharSequence>adapter2 = ArrayAdapter.createFromResource(this, sectorListId, android.R.layout.simple_spinner_item);\r\n            adapter2.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);\r\n            spinnerSector.setAdapter(adapter2);\r\n            spinnerSector.setOnItemSelectedListener(this);\r\n\r\n        }\r\n        else if(spin.getId() == R.id.select_tower)\r\n        {\r\n            //should we add confirmation button to confirm sending switch command or make it switch right away?\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void onNothingSelected(AdapterView<?> adapterView) {\r\n\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/example/radiocoveragetesting/testingActivity.java	(revision 7bd381ae72bc7c7e4eecd385fd2d8cf3b228d8ad)
+++ app/src/main/java/com/example/radiocoveragetesting/testingActivity.java	(date 1625680695791)
@@ -58,10 +58,14 @@
     Spinner spinnerBaseStation, spinnerSector;
     Boolean retryFetchStat;
     Boolean updateEnabled;
+    String selectedSector;
     private boolean justStarted;
 
 
-
+    /**
+     * Automatically used on creation
+     * @param savedInstanceState record of what state the app was in previously
+     */
     protected void onCreate(Bundle savedInstanceState) {
         Log.d("test", "the testingActivity works");
         super.onCreate(savedInstanceState);
@@ -302,7 +306,7 @@
                     e2.printStackTrace();
                 }
                 establishSshSession();
-                if (retryFetchStat) {
+                if (retryFetchStat) {  //checks that this is not the 2nd time in a row error has happened
                     retryFetchStat = false;
                     fetchStats();
                 }
@@ -342,6 +346,10 @@
         }
     }
 
+    /**
+     * Automatically called when the app is to be closed
+     * Need to end the network thread or else it will consume resources after app's death
+     */
     @Override
     protected void onDestroy() {
         super.onDestroy();
@@ -349,6 +357,13 @@
         sshHandler.getLooper().quit();
     }
 
+    /**
+     * Determines what action to take when user chooses something on spinner
+     * @param adapterView the spinner
+     * @param view I think context?
+     * @param position the location in terms of array
+     * @param l no idea
+     */
     @Override
     public void onItemSelected(AdapterView<?> adapterView, View view, int position, long l) {
         Spinner spin = (Spinner) adapterView;
@@ -383,12 +398,101 @@
         }
         else if(spin.getId() == R.id.select_tower)
         {
-            //should we add confirmation button to confirm sending switch command or make it switch right away?
+
         }
     }
 
     @Override
     public void onNothingSelected(AdapterView<?> adapterView) {
 
+    }
+
+    public void switchSector() {
+
+        switch (selectedSector) {
+
+        }
+
+        Runnable switchSector = new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    String command = "switch";
+
+                    // Open channel
+                    sshChannel.open().verify(5, TimeUnit.SECONDS);
+                    sshSession.resetIdleTimeout();
+
+                    try {
+                        OutputStream pipedIn = sshChannel.getInvertedIn();
+                        pipedIn.write(command.getBytes());
+                        System.out.println("sending command");
+                        pipedIn.flush();
+                        pipedIn.close();
+                    }
+                    catch (Exception e) {
+                        e.printStackTrace();
+                    }
+
+                    //You gotta capture the string rather than
+                    //scan it with scanner line-by-line because the stream constantly adds more
+                    String responseString = new String(responseStream.toByteArray());
+                    System.out.println("response string: \n" + responseString);
+                    //break down the string into lines
+                    String[] response = responseString.trim().split("\n");
+
+                    //if this is first time the method is running since ssh connection
+                    //was established, the output format will be wrong, so skip it once
+                    if(!justStarted) {
+                        //find the line containing the info we want
+                        String answerLine = response[response.length - 2];
+                        System.out.println("Testing line: " + answerLine);//show it to log to manually check
+                        //formatting the string
+                        String[] answerArray = answerLine.split(",");
+
+                        //I just did response 4-11 because I don't know the actual format of stats
+                        ans.add(answerArray[4]);  //snrUp
+                        ans.add(answerArray[5]);  //snrDown
+                        ans.add(answerArray[6]);  //peakSnrUp
+                        ans.add(answerArray[7]);  //peakSnrDown
+                        ans.add(answerArray[8]);  //avgPwrUp
+                        ans.add(answerArray[9]);  //avgPwrDown
+                        ans.add(answerArray[10]); //peakPwrUp
+                        ans.add(answerArray[11]); //peakPwrDown
+                    }
+                    justStarted = false;
+                    retryFetchStat = true;
+                }
+                catch (Exception e) {
+                    System.out.println("error in opening channel or getting response at fetchStat()");
+                    if((e instanceof SshChannelOpenException || e instanceof SshException) && (Objects.requireNonNull(e.getMessage()).trim().equals(
+                            "open failed") || Objects.requireNonNull(e.getMessage()).trim().equals(
+                            "Session has been closed"))) {
+                        sshChannel.close(true);
+                        sshSession.close(true);
+                        try {
+                            responseStream.close();
+                        }
+                        catch (IOException e2) {
+                            e2.printStackTrace();
+                        }
+                        try {
+                            errStream.close();
+                        }
+                        catch (IOException e2) {
+                            e2.printStackTrace();
+                        }
+                        establishSshSession();
+                        if (retryFetchStat) {  //checks that this is not the 2nd time in a row error has happened
+                            retryFetchStat = false;
+                            fetchStats();
+                        }
+
+                    }
+                    System.out.println("stacktrace for why first attempt failed");
+                    e.printStackTrace();
+                }
+            }
+        };
     }
 }
